package com.practice.common.service;

/**
 * @description: desc
 * @author: Francis
 * @date: 2023/11/28 10:55
 */
public class InterviewTypical150 {

    public static void main(String[] args) {
        int[] nums1 = new int[]{233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,233,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333,2333};
        int[] nums2 = new int[]{1,2,3,4,5};
//        System.out.println("result:" + removeDuplicates2(nums1));

        rotate(nums2,4);

    }

    /**
     * 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
     * @param nums
     * @param k
     */
    public static void rotate(int[] nums, int k) {
        if(k < 0 || nums.length < 1){
            return;
        }

        if(k > nums.length){
            k = k % nums.length;
        }

        int[] rotates = new int[k];
        int index =0;
        for(int i = nums.length-k; i < nums.length ; i++){
            rotates[index++] = nums[i];
        }

        for(int i = nums.length-k-1;i >=0; i--){
            nums[i +k] = nums[i];
        }

        for(int i = 0; i<k; i++){
            nums[i] = rotates[i];
        }

        printNums(nums);
    }

    /**
     * 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
     * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
     */
    public static int majorityElement(int[] nums) {
        if(nums.length < 1){
            return 0;
        }

        for(int i =0; i < nums.length;i++){
            int tempMax = nums[i];
            int index = i;
            for(int j =i+1; j<nums.length;j++){
                if(tempMax <= nums[j]){
                    tempMax = nums[j];
                    index = j;
                }
            }
            nums[index] = nums[i];
            nums[i] = tempMax;
        }

        if(nums.length < 2){
            return nums[0];
        }

        //删除最大的原始
        printNums(nums);
        int current = nums[0];
        int count =1;
        for(int i =1; i < nums.length;i++){
            if(nums[i] == current){
                i++;
                if(i > nums.length/2){
                    return current;
                }
            }else {
                current = nums[i];
                count = 1;
            }
        }

        return 0;

    }

    /**
     * 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
     * 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
     * @param nums
     * @return
     */
    public static int removeDuplicates2(int[] nums) {
        if(nums.length < 1){
            return 0;
        }
        int currentIndex = 1;
        int currentValue = nums[0];
        int currentCount = 1;
        int length =1;
       for(int i = 1 ; i< nums.length; i++){
           if(nums[i] != currentValue){
               currentValue = nums[i];
               currentCount = 0;
           }

            if(nums[i] != currentValue || ( nums[i] == currentValue && ++currentCount <=2)){
                nums[currentIndex++] = nums[i];
                length++;
            }
       }

        int[] result = new int[length];
        for(int i = 0; i < result.length; i++){
            result[i] = nums[i];
        }
        printNums(result);
       return length;
    }


    /**
     * 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
     * @param nums
     * @return
     */
    public static int removeDuplicates(int[] nums) {
        if(nums.length < 2){
            return nums.length;
        }
        int slow = 0;
        int fast = 1;
        int count = 0 ;
        while (fast < nums.length){
            if(nums[fast] != nums[slow]){
                nums[++slow] = nums[fast];
                count++;
            }
            fast++;
        }

        int[] result = new int[nums.length - count];

        for(int i = 0; i < result.length; i++){
            result[i] = nums[i];
        }
        printNums(result);

        return count;
    }

    public static int removeElement1(int[] nums, int val) {
        int index = 0;
        for(int i =0; i <nums.length;i++){
            if(nums[i] != val){
                nums[index ++] = nums[i];
            }
        }

        return index;
    }

    /**
     * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
     * 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
     * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
     * @param nums
     * @param val
     * @return
     */
    public static int removeElement(int[] nums, int val) {
        int[] flagNums = new int[nums.length];
        int removed = 0;
       for(int i =0 ; i< nums.length; i++){
           if(val == nums[i]){
               flagNums[i] = 1;
               nums[i] = 0;
               removed ++;
           }
       }

       int index = 0;
       for(int i= 0; i < nums.length;i++){
           if(0 == flagNums[i]){
               nums[index++] = nums[i];
           }
       }

       for (int i = (nums.length-removed); i < nums.length; i++){
           nums[i] =0;
       }
        printNums(nums);

       return nums.length - removed;
    }

    /**
     * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
     * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
     * @param nums1
     * @param m
     * @param nums2
     * @param n
     */
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int lastIndex = m;
        if(lastIndex == 0){
            for(int i = 0; i < n;i++){
                nums1[i] = nums2[i];
            }
        }else {
            for(int i=0; i<n;i++){
                int currentNum = nums2[i];
                for(int j =0; j < m+n; j++){

                    if(j == (m+n-1)){
                        nums1[j] = currentNum;
                        break;
                    }

                    if(currentNum < nums1[j] ){
                        // 如果不为0，先整体后移一位，最后给比较位赋值
                        for(int index = m+n-1; index > j;index --){
                            nums1[index] = nums1[index-1];
                        }
                        nums1[j] = currentNum;
                        lastIndex++;
                        break;
                    }

                    if( currentNum >= nums1[j]){
                        if(currentNum <= nums1[j+1]){
                            for(int index = m+n-1; index > j;index --){
                                nums1[index] = nums1[index-1];
                            }
                            nums1[j+1] = currentNum;
                            lastIndex++;
                            break;
                        }
                        if(nums1[j+1] == 0 && j+1 >= lastIndex){
                            for(int index = m+n-1; index > j;index --){
                                nums1[index] = nums1[index-1];
                            }
                            nums1[j+1] = currentNum;
                            lastIndex++;
                            break;
                        }
                    }
                }
            }
        }


        printNums(nums1);
    }

    private static void printNums(int[] nums) {
        StringBuilder sb = new StringBuilder("[");
        for (int i : nums) {
            sb.append(i).append(",");
        }
        if(sb.length() > 1){
            sb.deleteCharAt(sb.length()-1);
        }
        sb.append("]");
        System.out.println(sb.toString());
    }
}
